---
title: "コンテンツの更新ワークフロー"
---

(Original: https://docs.unity3d.com/Packages/com.unity.addressables@1.19/manual/ContentUpdateWorkflow.html)

# コンテンツ更新ワークフロー

Addressables では、CDNから動的にコンテンツをダウンロードするゲームを想定したコンテンツアップデートワークフローを提供しています。このような状況では、プレイヤー（アプリ、exe、apkなど）が作成され、（Androidアプリストアなどで）デプロイされます。このアプリは、実行中にCDNと通信し追加のコンテンツを見つけてダウンロードします。

これは、プラットフォームが提供するパッチシステムを使用するゲーム（SwitchやSteamなど）とは異なります。これらのゲームでは、ゲームのすべてのビルドが、アップデートフローを完全に回避した、完全に新しいコンテンツのビルドである必要があります。この場合、ビルドのたびに生成されるaddressable_content_state.binファイルは、破棄または無視することができます。

## プロジェクトの構造

Unityでは、ゲームコンテンツを2つのカテゴリに分類することを推奨しています。

- `Cannot Change Post Release`: 更新する必要のない静的なコンテンツ
- `Can Change Post Release`: アップデートが予想される動的コンテンツ


ここでいうリリースとは、技術的には、ビルドされた Addressables Contents のリリースのことで、プレイヤービルドがまだリリースされていない場合は、プレイヤービルドと一緒にリリースされます。プレイヤービルドがリリースされた後、これらのゲームコンテンツカテゴリーは、コンテンツアップデートのリリースに関連します。新しい remote Addressable Groups は、新しいプレーヤービルドをリリースすることなく、コンテンツアップデートに組み込むことができます。

この構造では、`Cannot Change Post Release`とマークされたコンテンツは、アプリケーションと一緒にリリースされ（またはインストール後すぐにダウンロードされ）、大きなバンドルにはほとんど含まれません。`Can Change Post Release`とされたコンテンツは、オンライン上に置かれますが、理想的には、より小さなバンドルで、各アップデートに必要なデータ量を最小限に抑えることができます。Addressable Assets System の目標の一つは、スクリプトを変更することなく、この構造を簡単に扱え、変更できるようにすることです。

しかし、Addressable Assets Systemでは、アプリケーションを全く新しいビルドで発行したくない場合に、`Cannot Change Post Release`とマークされたコンテンツを変更しなければならない状況にも対応できます。変更されたアセットとその依存関係（および従属関係）は、リリースされたコンテンツの代わりに使用される新しいバンドルに複製されます。これにより、バンドル全体を置き換えたり、ゲームを再構築するよりも、はるかに小規模なアップデートが可能になります。ビルドを作成した後は、完全に新しいビルドを作成するまで、グループの状態を`Cannot Change Post Release`から`Can Change Post Release`、またはその逆に変更しないことが重要です。コンテンツのフルビルド後、コンテンツのアップデート前にグループを変更してしまうと、Addressableはアップデートに必要な正しい変更を生成できません。

なお、リモートアップデートができない場合（現行のビデオゲーム機の多くや、サーバーのないゲームなど）は、毎回完全な新規ビルドを行う必要があります。

## 仕組み

Addressables では、コンテンツカタログを使用して各アセットにアドレスをマッピングし、どこでどのようにロードするかを指定します。このマッピングを変更する機能をアプリに提供するには、オリジナルのアプリがこのカタログのオンラインコピーを認識している必要があります。この設定を行うには、`AddressableAssetSettings` インスペクタの **Build Remote Catalog** 設定を有効にします。これにより、カタログのコピーが指定されたパスに構築され、そこからロードされるようになります。このロードパスは、アプリが出荷された後は変更できません。コンテンツの更新プロセスでは、カタログの新しいバージョン（同じファイル名）が作成され、以前に指定したロードパスにあるファイルが上書きされます。

アプリケーションをビルドすると、固有のアプリコンテンツバージョン文字列が生成され、各アプリがどのコンテンツカタログをロードすべきかが識別されます。1つのサーバーには、アプリの複数のバージョンのカタログを衝突することなく格納できます。必要なデータは、`addressables_content_state.bin` ファイルに格納されます。binファイルは、新しいコンテンツのビルド時にのみ生成されます。このファイルには、バージョン文字列と、`Cannot Change Post Release` とマークされたグループに含まれるすべてのアセットのハッシュ情報が含まれています。デフォルトでは、`Assets/AddressableAssetsData/<platform>` Project ディレクトリ、または `AddressbleAssetSettings` の値 `ContentStateBuildPath` に `/<platform>` を付加して割り当てられたパスに配置されます。`<platform>` はターゲットとなるプラットフォームです。

`addressables_content_state.bin` ファイルには、Addressables システムのすべての `Cannot Change Post Release` Assetグループのハッシュと依存関係の情報が含まれています。`StreamingAssets` フォルダに構築されているすべてのグループを`Cannot Change Post Release`とする必要がありますが、大規模なリモートグループにはこの指定が有効な場合もあります。次のステップ（後述のコンテンツ更新の準備）では、このハッシュ情報により、変更されたアセットを含む`Cannot Change Post Release`グループがあるかどうかを判断し、そのアセットを別の場所に移動する必要があるかどうかを判断します。

`addressables_content_state.bin` の詳細については、[FAQページ TODO]()を参照してください。

### アップデートライフサイクル

コンテンツを構築するプロセスの最初のステップは、常にフレッシュなフルビルドです。この作業は、ユニティエディタのAddressables Groupsウィンドウから行うことができます（**Window > Asset Management > Addressables > Groups**）。そのウィンドウで、**Build > New Build** からビルドスクリプトを選択します。カスタムビルドを作成しない限り、選択肢は **Default Build Script** のみとなります。

プレイヤー用のフルビルドを作成するときは（**File > Build and Run** など）、その前に Addressables のコンテンツ用フルビルドを作成する必要があります。プレーヤービルドを作成した後、CDN 経由でコンテンツを更新したい場合は、コンテンツ更新ビルドを行う必要があります。

#### ライフサイクルの例

これは、ゲームの存続期間中のフローの一例です。主要なステップの詳細は、このドキュメントの後半で説明されています。

- Step1: 初期リリースの準備が整うまで、コンテンツの作成と改良を行います。
- Step2: Groups ウィンドウで、アドレス指定可能なコンテンツの初期構築を開始します。
- Step3: Build and Run などでプレイヤーをビルドする。
- Step4: コンテンツの改良を続けます。

CDNを持たず、コンテンツを動的にダウンロードしていない場合は、ステップ4の後、ステップ2に戻り、新しいコンテンツのビルドと新しいプレーヤーを作成します。

CDNでコンテンツを配信している場合は、より多くのステップを繰り返します。ここでは、上記のステップ3で構築したプレーヤーを "PlayerBuild1" とします。手順は以下のように続きます。

- Step5: オプションで **Check for Content Update Restrictions** を実行する（後述の「変更されたアセットの識別」を参照）。
- Step6: **Update a Previous Build**（以前のビルドを更新する）でコンテンツ更新ビルドをトリガーする（下記の「コンテンツ更新用のビルド」を参照）。

この時点で、選択したプラットフォームに送信する新しいプレーヤーを作成する準備ができるまで、ステップ4～6を繰り返すことができます。

- Step7: 必要に応じて、addressables_content_state.binファイルを保存し、コンテンツを分岐させます。
- Step8: 必要に応じて、CDNに新しいビルド先を作成します。特に、Unityのバージョンを変更する場合は注意が必要です。

新しいプレイヤーを作成する際には、2つのシナリオが考えられます。最も単純なケースでは、「PlayerBuild1」に新しいコンテンツを配布することはありません。これまでに「PlayerBuild1」で公開したコンテンツは、ユーザーが将来のプレーヤービルドにアップデートするまでの間、すべてのユーザーに提供されます。このシナリオでは、ステップ7は行わず、ステップ6からステップ2に戻り、今度は「PlayerBuild2」を作成して、そのコンテンツの更新のみを行います。

もっと複雑なシナリオでは、「PlayerBuild2」を作成しつつ、新しいコンテンツを両方のプレイヤーに提供したい場合です。この場合、ステップ7でaddressables_content_state.binを保存する必要があります。最も簡単な方法は、コンテンツを完全に分岐させることです。これにより、各ビルドのカタログやコンテンツに適切な名前が付けられます。これを回避する方法もありますが、その場合は標準のカタログ作成や命名システムから離れることになります。

ステップ8の目的は、各プレイヤーのビルドに、コンテンツをダウンロードするためのクリーンなスペースを確保することです。多くの場合、これは必要ありませんが、より安全です。絶対に必要な例としては、Unityのバージョンは更新したが、一部のコンテンツは更新していない場合が挙げられます。AssetBundleが同一のコンテンツで構築されていても、2つの異なるUnityのバージョンがあれば、ハッシュは同じですが、CRCは異なります。これは、どのようなバンドル命名方式でも、新しいバンドルは古いバンドルと同じ名前になることを意味します（つまり上書きされます）。また、新しいCRCを持っているので、古いプレーヤーは正常にダウンロードできません（ダウンロードの安全性のため、カタログにCRCを記録しています）。

## コンテンツ更新の計画

コンテンツの更新を計画する際には、初期構築（上記ステップ2）の際に正しく設定されていることを確認する項目がいくつかあります。まず、前述のように正しいグループに「変更可能」または「変更不可」のタグが付けられていることです。次に、このビルドで生成された addressables_content_state.bin ファイルが保存されていることです。デフォルトでは、`Assets/AddressableAssetsData/<platform>` プロジェクトのディレクトリ、または `AddressbleAssetSettings` の値 `ContentStateBuildPath` に割り当てられたパスに `/<platform>` を付加した形でビルドされます。ここで `<platform>` はターゲットとなるプラットフォームです。この時点で、バージョンコントロールを使ってファイルを保存することをお勧めします。

### フルリビルドが必要な場合

Addressable は、コードではなくコンテンツを配信することしかできません。そのため、コードを変更した場合は、プレイヤーのビルドをやり直す必要があり、コンテンツのビルドもやり直す必要があります。新しいプレイヤーが CDN から古いコンテンツをダウンロードできる場合もありますが、その場合は、最初のビルドで作成されたツリーの種類を慎重に分析する必要があります。これは、慎重に検討すべき高度な領域です。

Addressables 自体がコードなので、Addressables や Unity のバージョンを更新するには、プレイヤーの新規ビルドとコンテンツの新規ビルドが必要になることが多いことに注意してください。

### Unique Bundle IDs

Unique Bundle IDs は高度なオプションで、古いバージョンのコンテンツがメモリに残っている状態で新しいバージョンのコンテンツをロードする機能が必要な場合にのみ有効にしてください。このオプションがオンになっていると、ビルドやコンテンツのリフレッシュに関連する追加コストが発生します。

AssetBundles をメモリにロードする際、Unity は2つのバンドルを同じ内部名でロードできないようにしています。このため、ランタイムでのバンドルの更新には制限があります。Addressables は初期化以外でのカタログの更新をサポートしているので、すでにロードしたコンテンツを更新することが可能です。

これを実現するには、2つのうちの1つを実行する必要があります。1つは、カタログを更新する前に、すべての Addressables コンテンツをアンロードすることです。これにより、古い名前の新しいバンドルがメモリ上で競合を起こさないようにします。2つ目の方法は、更新された AssetBundles がユニークな内部識別子を持つようにすることです。これにより、古いバンドルがメモリ上に残っていても、新しいバンドルをロードすることができます。この2つ目のオプションを有効にするためのオプションがあります。`AddressableAssetSettings` インスペクタ内の "Unique Bundle IDs" をオンにします。このオプションの欠点は、依存関係の連鎖の中でバンドルを再構築する必要があることです。つまり、あるグループのマテリアルを変更した場合、デフォルトではそのマテリアルのバンドルだけが再構築されることになります。"Unique Bundle IDs" をオンにすると、そのマテリアルを参照するすべてのアセットも再構築する必要があります。

## 変更されたアセットの識別

`Cannot Change Post Release` グループに変更されたアセットがある場合は、**Check for Content Update Restrictions** コマンドを実行する必要があります（上記ステップ5）。これにより、変更された Asset、その依存関係（バンドル名が変更されている場合）、および変更された Asset に依存する他のすべてのAssetが、`Cannot Change Post Release` グループから削除され、新しいグループに移動されます。新しいアセットグループを作成するには、以下の手順に従います。

1. Unity Editor で **Addressables Groups** ウィンドウを開きます（**Window > Asset Management > Addressables > Groups**）。
1. **Addressables Groups**ウィンドウで、上部メニューバーの **Tools** を選択し、 **Check for Content Update Restrictions** を選択します。
1. 開いた **Build Data File** ダイアログで、addressables_content_state.bin ファイルを選択します（デフォルトでは、`Assets/AddressableAssetsData/<platform>` Projectディレクトリ、または `AddressbleAssetSettings` の値`ContentStateBuildPath` に `/<platform>` を付加したパスに配置されています。`<platform>` はターゲットとなるプラットフォーム）を指定します。)

このデータは、アプリケーションが最後にビルドされてから、どの Assets や依存関係が変更されたかを判断するために使用されます。システムは、これらのアセット、その依存関係（バンドル名が変更されている場合）、および変更されたアセットに依存する他のすべてのアセットを新しいグループに移動させ、コンテンツ アップデート ビルドに備えます。

注：すべての変更が `Can Change Post Release` グループに限定されている場合、このコマンドは何もしません。

重要：prepareオペレーションを実行する前に、Unityはバージョンコントロールシステムをブランチ化することを推奨します。prepareオペレーションは、コンテンツのアップデートに適した方法でAssetグループを再配置します。分岐することで、次回、新しいプレイヤーを出荷する際に、希望のコンテンツ配置に戻すことができます。

## コンテンツの更新に備えた構築

コンテンツのアップデートに備えて構築するには

1. Unity Editor で **Addressables Groups** ウィンドウを開きます（**Window > Asset Management > Addressables > Groups**）。
1. **Addressables Groups** ウィンドウで、トップメニューの Build を選択し、**Update a Previous Build** を選択します。
1. 開いた **Build Data File** ダイアログで、既存のアプリケーションビルドのビルドフォルダを選択します。ビルドフォルダには、`addressables_content_state.bin` ファイルが含まれていなければなりません（デフォルトでは、`Assets/AddressableAssetsData/<platform>` Project ディレクトリ、または `AddressbleAssetSettings` の値 `ContentStateBuildPath` に割り当てられたパスに `/<platform>` を付加したものになっています。`<platform>` はターゲットとなるプラットフォーム）を指定します。)

ビルドでは、コンテンツカタログ、ハッシュファイル、AssetBundles が生成されます。

生成されたコンテンツ カタログは、選択されたアプリケーション ビルドのカタログと同じ名前になり、古いカタログとハッシュ ファイルが上書きされます。アプリケーションはハッシュファイルを読み込んで、新しいカタログが利用可能かどうかを判断します。システムは、アプリケーションと一緒に出荷された、または既にダウンロードされた既存のバンドルから変更されていないアセットをロードします。

システムは、addressables_content_state.bin ファイルのコンテンツ バージョン ストリングとロケーション情報を使用して AssetBundles を作成します。更新されたコンテンツを含まない AssetBundle は、更新のために選択されたビルドのものと同じファイル名を使用して書き込まれます。AssetBundle に更新されたコンテンツが含まれている場合は、更新されたコンテンツを含む新しい AssetBundle が生成され、元のコンテンツと共存できるように新しいファイル名が付けられます。新しいファイル名を持つAssetBundleのみを、コンテンツをホストする場所にコピーする必要があります。

システムは、変更できないコンテンツ用のアセットバンドルも構築しますが、Addressable Assetエントリが参照しないため、コンテンツのホスティング先にアップロードする必要はありません。

なお、新しいプレーヤーを構築してからコンテンツを更新するまでの間に、ビルドスクリプトを変更しないでください（プレーヤーコード、アドレス指定など）。アプリケーションで予期せぬ動作が発生する可能性があります。

また、Addressablesのビルドで作成されたローカル コンテンツ バンドルをProject Libraryフォルダから削除すると、ゲームやアプリケーションをエディターで実行し、「Use Existing Build (requests built groups) Play Mode」スクリプトを使用しても、バンドル内のアセットをロードしようとしても失敗します。

## 実行時にコンテンツの更新をチェックする

カスタムスクリプトを追加して、Addressables の新しいコンテンツの更新があるかどうかを定期的にチェックすることができます。アップデートの開始には、以下の関数呼び出しを使用します。

`public static AsyncOperationHandle<List<string>> CheckForCatalogUpdates(bool autoReleaseHandle = true)`

ここで、List<string> には、変更されたロケータIDのリストが含まれています。このリストをフィルタリングして特定のIDだけを更新することもできますし、UpdateCatalogs APIに完全に渡すこともできます。

新しいコンテンツがある場合は、更新を実行するボタンをユーザーに提示するか、自動的に実行することができます。古くなったAssetが解放されたことを確認するのは開発者次第であることに注意してください。

カタログのリストはNULLでもよく、その場合は以下のスクリプトで更新が必要なカタログをすべて更新します。

`public static AsyncOperationHandle<List<IResourceLocator>> UpdateCatalogs(IEnumerable<string> catalogs = null, bool autoReleaseHandle = true)`

戻り値は、更新されたロケータのリストです。

## コンテンツ更新の例

この例では、出荷されたアプリケーションが以下のグループを認識しています。

| `Local_Static` | `Remote_Static` | `Remote_NonStatic` |
| ---- | ---- | ---- |
| `AssetA` | `AssetL` | `AssetX` |
| `AssetB` | `AssetM` | `AssetY` |
| `AssetC` | `AssetN` | `AssetZ` |

なお、`Local_Static` と `Remote_Static` は、`Cannot Change Post Release` グループに属しています。

このバージョンが公開された時点で、デバイスに `Local_Static` が設定されているプレイヤーがおり、リモートバンドルのいずれかまたは両方がローカルにキャッシュされている可能性があります。

各グループ（`AssetA`、`AssetL`、`AssetX`）のアセットを1つずつ変更してから、**Check for Content Update Restrictions** を実行すると、ローカルの Addressable 設定の結果は以下のようになります。

| `Local_Static` | `Remote_Static` | `Remote_NonStatic` | `content_update_group (non-static)` |
| ---- | ---- | ---- | ---- |
| | | `AssetX` | `AssetA` |
| `AssetB` | `AssetM` | `AssetY` | `AssetL` |
| `AssetC` | `AssetN` | `AssetZ` | |

この準備作業では、`Cannot Change Post Release` グループが実際に編集されることに注意してください。しかし、重要なのは、システムは上記のレイアウトを構築しますが、そのようなグループの構築結果は破棄されるということです。そのため、プレイヤーの視点では以下のようになります。

| `Local_Static` |
| ---- |
| `AssetA` |
| `AssetB` |
| `AssetC` |

`Local_Static` バンドルは、プレーヤーのデバイスにすでに存在しており、これを変更することはできません。この古いバージョンの`AssetA` は、もはや参照されません。代わりに、デッドデータとしてプレイヤーデバイスに貼り付けられています。

| `Remote_Static` |
| ---- |
| `AssetL` |
| `AssetM` |
| `AssetN` |

`Remote_Static` バンドルに変更はありません。プレイヤーのデバイスにキャッシュされていない場合は、`AssetM` または `AssetN` がリクエストされたときにダウンロードされます。`AssetA` と同様に、この古いバージョンの `AssetL` はもはや参照されません。

| `Remote_NonStatic` (old) |
| ---- |
| `AssetX` |
| `AssetY` |
| `AssetZ` |

`Remote_NonStatic` バンドルは古くなりました。サーバーから削除することもできますが、どちらにしてもこの時点からダウンロードされることはありません。キャッシュされている場合は、いずれキャッシュから削除されます。`AssetA` や `AssetL` と同様に、この古いバージョンの `AssetX` はもう参照されません。

| `Remote_NonStatic` (new) |
| ---- |
| `AssetX` |
| `AssetY` |
| `AssetZ` |

古い `Remote_NonStatic` バンドルが、ハッシュファイルで区別される新しいバージョンに置き換えられます。修正版の `AssetX` は、この新しいバンドルで更新されます。

| `content_update_group` |
| ---- |
| `AssetA` |
| `AssetL` |

`content_update_group` バンドルは、今後参照される変更された Assets で構成されています。

上記の例では、以下のような影響があることに注意してください。

1. 変更されたローカルアセットは、ユーザーのデバイス上で永久に使用されません。
1. ユーザーが非静的なバンドルをすでにキャッシュしている場合、変更されていないアセット（この例では、例えば `AssetY` と `AssetZ`）を含めて、バンドルを再ダウンロードする必要があります。理想的には、ユーザーがバンドルをキャッシュしていない場合は、新しい `Remote_NonStatic` バンドルをダウンロードする必要があります。
1. ユーザーが `Static_Remote` バンドルをすでにキャッシュしている場合は、更新されたアセット（この例では、`content_update_group` 経由の `AssetL`）をダウンロードするだけで済みます。これは、このケースでは理想的です。ユーザーがバンドルをキャッシュしていない場合は、`content_update_group` 経由の新しい `AssetL` と、手つかずの `Remote_Static` バンドル経由の今は亡き `AssetL` の両方をダウンロードする必要があります。最初のキャッシュの状態に関わらず、ユーザーはある時点で、一度もアクセスされていないにも関わらず、無期限にキャッシュされた消滅した `AssetL` をデバイス上に持つことになります。

リモートコンテンツに最適な設定は、それぞれのユースケースによって異なります。

## コンテンツ更新による依存関係の処理方法

コンテンツ更新の一環として再構築が必要であると判定されるのは、アセットを直接変更する場合だけではありません。アセットの依存関係を変更することは、アップデートを行う際に考慮される、あまり目立たない要素です。

上の例の一部を見てみましょう。

| `Local_Static` |
| ---- |
| `AssetA` |
| `AssetB` |
| `AssetC` |

ここではいくつかのアセットに関する情報を想定してみましょう。例えば、次のような依存関係の連鎖があるとします。「`AssetA` は`Dependency1` に依存し、それは `Dependency2`に依存」しています。 「`AssetB` は `Dependency2` に依存」し、「`AssetC` は `Dependency3` に依存」しています。ここで、3つの依存関係には、Addressable と Addressable ではない assets が混在しています。

ここで、`Dependency1` のみを変更し、Check For Content Update Restriction を実行すると、プロジェクトの構造は次のようになります。

| `Local_Static` | `content_update_group` |
| ---- | ---- |
| | `AssetA` |
| `AssetB` | |
| `AssetC` | |

`Dependency2` のみを変更した場合。

| `Local_Static` | `content_update_group` |
| ---- | ---- |
| | `AssetA` |
| | `AssetB` |
| `AssetC` | |

最後に、`Dependency3` のみを変更した場合。

| `Local_Static` | `content_update_group` |
| ---- | ---- |
| `AssetA` | |
| `AssetB` | |
| | `AssetC` |

これは、依存関係が変更されると、依存関係ツリー全体を再構築する必要があるためです。
もう1つの例として、以下のような依存関係のツリーを見てみましょう。`AssetA depends on AssetB which depends on Dependency2` `AssetB depends on Dependency2` `AssetC depends on Dependency3` さて、`Dependency2` を変更した場合、プロジェクトの構造は次のようになります。

| `Local_Static` | `content_update_group` |
| ---- | ---- |
| | `AssetA` |
| | `AssetB` |
| `AssetC` | |

なぜなら、`AssetA` は `AssetB` に依存しており、`AssetB` は `Dependency2` に依存しているからです。チェーン全体を再構築する必要があるため、`AssetA` と `AssetB` の両方が `content_update_group` に入れられます。

